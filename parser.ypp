%{
    #include "hw3_symbol_table.hpp"
    #include "hw3_enum_list.hpp"
    #include "hw3_expression.hpp"
    #include "hw3_relop_api.hpp"
    #include "hw3_master.hpp"
    #include "hw3_output.hpp"
    #include <iostream>
    extern int yylex();
    extern int yylineno;
    void output::printProductionRule(int ruleno);
    void output::errorLex(int lineno);
    void output::errorSyn(int lineno);
    void yyerror(const char* message);
	int main();
    using namespace std;
	using namespace output;
%}



%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token AUTO
%token TRUE
%token FALSE
%token RETURN
%token IF
%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token LPAREN
%token LBRACE
%token RBRACE
%token ID
%token NUM
%token STRING

%right ASSIGN
%left OR
%left AND
%nonassoc RELOP
%left BINOP_ADDATIVE
%left BINOP_MULTIPLY
%right NOT
%left RPAREN
%nonassoc ELSE


%%

Program:        Funcs                                                       {output::printProductionRule(1);}
;
Funcs:          /*epsilon*/ 			                                                {output::printProductionRule(2);}
                | FuncDecl Funcs                                            {output::printProductionRule(3);}
;
FuncDecl:       RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE   {output::printProductionRule(4);}
;
RetType:        Type                                                        {output::printProductionRule(5);}
                |VOID                                                       {output::printProductionRule(6);}
;
Formals:        /*epsilon*/                                                				{output::printProductionRule(7);}
                |FormalsList                                                {output::printProductionRule(8);}
;
FormalsList:    FormalDecl                                                  {output::printProductionRule(9);}
                |FormalDecl COMMA FormalsList                               {output::printProductionRule(10);}
;
FormalDecl:     Type ID                                                     {output::printProductionRule(11);}
;
Statements:     Statement                                                   {output::printProductionRule(12);}
                |Statements Statement                                       {output::printProductionRule(13);}
;
Statement:      LBRACE Statements RBRACE                                    {output::printProductionRule(14);}
                | Type ID SC                                                {output::printProductionRule(15);}
                | Type ID ASSIGN Exp SC                                     {output::printProductionRule(16);}
                | AUTO ID ASSIGN Exp SC                                     {output::printProductionRule(17);}
                | ID ASSIGN Exp SC                                          {output::printProductionRule(18);}
                | Call SC                                                   {output::printProductionRule(19);}
                | RETURN SC                                                 {output::printProductionRule(20);}
                | RETURN Exp SC                                             {output::printProductionRule(21);}
                | IF LPAREN Exp RPAREN Statement                            {output::printProductionRule(22);}
                | IF LPAREN Exp RPAREN Statement ELSE Statement             {output::printProductionRule(23);}
                | WHILE LPAREN Exp RPAREN Statement                         {output::printProductionRule(24);}
                | BREAK SC                                                  {output::printProductionRule(25);}
                | CONTINUE SC                                               {output::printProductionRule(26);}
;
Call :          ID LPAREN ExpList RPAREN                                    {output::printProductionRule(27);}
                | ID LPAREN RPAREN                                          {output::printProductionRule(28);}
;
ExpList:        Exp                                                         {output::printProductionRule(29);}
                | Exp COMMA ExpList                                         {output::printProductionRule(30);}
;
Type :          INT                                                         {output::printProductionRule(31);}
                | BYTE                                                      {output::printProductionRule(32);}
                | BOOL                                                      {output::printProductionRule(33);}
;
Exp:            LPAREN Exp RPAREN                                           {output::printProductionRule(34);}
                | Exp BINOP_MULTIPLY Exp                                    {output::printProductionRule(35);}
                | Exp BINOP_ADDATIVE Exp                                    {output::printProductionRule(35);}
                | ID                                                        {output::printProductionRule(36);}
                | Call                                                      {output::printProductionRule(37);}
                | NUM                                                       {output::printProductionRule(38);}
                | NUM B                                                     {output::printProductionRule(39);}
                | STRING                                                    {output::printProductionRule(40);}
                | TRUE                                                      {output::printProductionRule(41);}
                | FALSE                                                     {output::printProductionRule(42);}
                | NOT Exp                                                   {output::printProductionRule(43);}
                | Exp AND Exp                                               {output::printProductionRule(44);}
                | Exp OR Exp                                                {output::printProductionRule(45);}
                | Exp RELOP Exp                                             {output::printProductionRule(46);}		
                | LPAREN Type RPAREN Exp                                    {output::printProductionRule(47);}
;

%%

void yyerror(const char*){

    output::errorSyn(yylineno);
    exit(0);
}


int main()
{
    init();
    printLog("Start");
    int result = yyparse();
    SymbolTable.gg();
    printLog("End");
    close();
    return result;
}